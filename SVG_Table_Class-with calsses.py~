# -*- coding: utf-8 -*-
# <nbformat>3.0</nbformat>

# <headingcell level=1>

# SVG Table Class

# <codecell>

from IPython.display import SVG

# <markdowncell>

# These functions are used to build the elements of the table.

# <codecell>

class rectangle(object):
    """This object contains top_left, bottom_right, background, border_color, line_width"""
    def __init__(self):
        self.top_left = [0,0]
        self.bottom_right = [100, 30]
        self.background = (255,255,255)#white background
        self.border_color = (0,0,0)#border color
        self.line_width = 1 #line width

def draw_rec(rect_obj):
    #self.__bottom_right_check__()
    BR = rect_obj.bottom_right
    TL = rect_obj.top_left
    back = rect_obj.background
    stroke_clr = rect_obj.border_color
    lin_width = rect_obj.line_width
    svc_rec_list = ['<rect ',
                    'height="{}"'.format(BR[1]),
                    'width="{}" '.format(BR[0]-TL[0]),
                    'style="',
                    'fill:rgb{};'.format(back),
                    'stroke:rgb{};'.format(stroke_clr),
                    'stroke-width:{}" '.format(lin_width),
                    'x="{}" '.format(TL[0]+lin_width),
                    'y="{}" />\n'.format(TL[1]+lin_width)] #-TL[1]
    return ' '.join(svc_rec_list)

def SVG_text(TL=(0,0), font_size=12, height=16, text='', font_color=(0,0,0), font_weight='normal', x_shift=0):
    """This function generates the SVG text to display text.  It also supports multiple line text is \n is in the text"""
    #print(TL)
    x,y = TL
    if '\n' in text:
        y+=font_size+1
    else:
        y+=int(floor((height+font_size)/2))-1
    x += round(font_size/2) + x_shift
    list_of_text = text.split('\n')
    add_list=[]
    if len(list_of_text)>1:
        for index, text in enumerate(list_of_text[1:]):
            inst_y = y+(index+1)*(font_size+2)
            add_text = '<tspan x="{}" y="{}">'.format(x, inst_y)+text+'</tspan>'
            add_list.append(add_text)
    Text_list = ['<text x="{}" '.format(x),
                 'y="{}" '.format(y),
                 'font-size= "{}" '.format(font_size),
                 'font-weight = "{}"'.format(font_weight),
                 'style="fill:rgb{}">'.format(font_color),
                 list_of_text[0]]
    Text_list+=add_list
    Text_list+=['</text>\n'] #, 'fill={} ','font-style= "{}" ',"""
    return " ".join(Text_list)

a="""<text x="10" y="20" style="fill:red;">Several lines:
    <tspan x="10" y="45">First line</tspan>
    <tspan x="10" y="70">Second line</tspan>
  </text>"""

def Set_SVG_view(width, height, svg_display_text):
    """This function sets the viewbox and the height of an SVG object."""
    text = '<SVG viewBox="0 0 {width} {height}" height="{height}">'.format(width=width, height=height)
    text+=svg_display_text+'</SVG>'
    return(text)

# <codecell>

a=[1,2,3]
a[1:]

# <codecell>

rect = rectangle()
#rect??
Set_SVG_view(100,30,'<rect  height="30" width="100"  style=" fill:rgb(255, 255, 255); stroke:rgb(0, 0, 0); stroke-width:1"  x="1"  y="1" />')

# <codecell>

a='''<SVG viewBox="0 0 102 32" height="32"><rect  height="30" width="100"  style=" fill:rgb(255, 255, 255); stroke:rgb(0, 0, 0); stroke-width:1"  x="1"  y="1" />
<text x="7"  y="21"  font-size= "14"  font-weight = "bold" style="fill:rgb(0, 0, 0)"> Header </text>
<line x1="40" y1="1" x2="40" y2="31" style="stroke:rgb(0, 0, 0);stroke-width:1"/></SVG>'''
SVG(a)

# <headingcell level=3>

# Classes

# <markdowncell>

# This is a class developed to draw SVG tables with text for IPython Qick Referance.

# <codecell>

class SVG_Text(object):
    """This is a base class for handeling text objects"""
    def __init__(self, text="", font_size=12, font_color=(0,0,0), font_weight="normal", border_width=1, TL=(0,0)):
        """Initiailize"""
        self.line_width = self.check_line_width(border_width)
        self.font_weight = self.check_font_weight(font_weight)
        self.font_color = self.check_color(font_color)
        self.__font_size__ = self.check_font_size(font_size)
        self.__height__ = self.check_height(self.__font_size__, self.line_width)
        self.text = text
        self.Top_left = TL
        #self.set_font_size(self.font_size, font_size, self.height, self.line_width)

   
    def check_font_weight(self, font_weight):
        """This method validates the font_weight then returens it. Valid weights are
            normal | bold | bolder | lighter | 100 | 200 | 300| 400 | 500 | 600 | 700 | 800 | 900"""
        validweights = ["normal", "bold", "bolder", "lighter", 100, 200, 300, 400, 500,
                        600, 700, 800, 900, '100', '200', '300', '400', '500', '600', 
                        '700', '800', '900']
        try:
            assert(font_weight in validweights)
            return font_weight
        except:
            raise(RuntimeError("Font weight must be one of the following: {}".format(validweights)))
    
    def check_line_width(self, border_width):
        """This method validates the border_width then returns it."""
        try:
            assert(border_width>=0 and border_width == int(border_width))
            return border_width
        except:
            raise(RuntimeError("Line widths must be a positive integer.")) 
    
    def check_font_size(self, size):
        """This method validates size and returns it"""
        try:
            assert(size>3 and size == int(size))
            return size
        except:
            raise(RuntimeError("Font size must be an integer greater then 3.")) 
    
    def check_color(self, color):
        """This method is used to set the color of color_to_set or raise an error if
           the RGV values are invalid."""
        try:
            assert(min(color)>=0 and max(color)<256)
            return color
        except:
            raise(RuntimeError("RGB color values must be between 0 and 255 inclusive"))
    
    def check_height(self, font_size, border_width, height_to_check=0):
        """The method determines the minimum height based on the font_size 
           and the with of the lines on top and bottom.  Returns the greater 
           of set_height and the minimum height to set_height."""
        min_height = font_size+2*border_width+2
        return max(min_height, height_to_check)
        
        
    def set_font_size(self, font_size_to_set, size, height_to_set=0, border_width=0):
        """This method validates size then sets font_size_to_set.  If 
           border_width and height_to_set are provided then it will also update the 
           height_to_set."""
        self.__font_size__ = self.check_font_size(size)
        self.__height__ = self.check_height(self.__font_size__, border_width, self.__height__)
        
    def set_height(self, height):
        self.__height__ = self.check_height(self.__font_size__, border_width, self.__height__)
        
    
    def get_SVG_text(self):
        return SVG_text(self.Top_left, self.__font_size__, self.__height__, self.text, self.font_color, self.font_weight)
        

# <codecell>

test=SVG_Text("testing")
SVG(test.get_SVG_text())

# <codecell>


# <codecell>

class Table_Header(SVG_Text):
    """This is a header object for the top row of a table.  If the header text using 
       the set_header_text (or this is created with the header text) the header will
       be set to show (self.Show_header = True)."""
    def __init__(self, text="", bordercolor=(0,0,0), height=30, size=14, font_color=(0,0,0), background=(255,255,255), line_width=1, TL=(0,0), width=100):
        """Initiailize"""
        super().__init__(text, size, font_color, "bold", line_width, TL)#text, size, font_color, "bold", line_width, TL
        self.Show_header = False
        self.Header_width = width
        self.set_header_text(text)
        self.__height__ = self.check_height(self.__font_size__, self.line_width, height)
        self.Header_border_color = self.check_color(bordercolor)
        self.Header_background = self.check_color(background)
    
    def set_header_text(self, text=""):
        """This method let the user set the text of the header of the table.  By default if the text is set then the
           header is set to show but it can be turned off by setting self.Show_header=False."""
        if len(text)>0:
            self.text = text
            self.Show_header = True
        else:
            print("No header was added")
            
    @property
    def bottom(self):
        return self.__height__+self.line_width
    
    def get_SVG_header(self):
        if self.Show_header:
            #rect_dict = {'top_left':self.Top_left,'bottom_right':[self.Header_width,self.__height__],
            #             'back':self.Header_background,'color':self.Header_border_color,
            #             'line width':self.line_width}
            rect_obj = rectangle()
            rect_obj.top_left = self.Top_left
            rect_obj.bottom_right = [self.Header_width,self.__height__]
            rect_obj.background = self.Header_background
            rect_obj.border_color = self.Header_border_color
            rect_obj.line_width = self.line_width
            Text = draw_rec(rect_obj)
            Text += SVG_text(self.Top_left, self.__font_size__, self.__height__, self.text, 
                             self.font_color, self.font_weight)
            return Text 
        else:
            return ""

# <codecell>

head=Table_Header(text="Header",width=100)
print(head.text)
print(head.bottom)
#print(head.text)
#head.header_exists

# <codecell>

head=Table_Header(text="Header",width=100)
print(head.get_SVG_header())
Text=Set_SVG_view(102, head.bottom+1, head.get_SVG_header())
print(Text)
SVG(Text)

# <markdowncell>

# ####You should see a white rectangle the header text inside above

# <codecell>

class Table_rows(SVG_Text):
    def __init__(self, font_size=12, line_width=1, top_left=(0,0), text_list=[], width=100, font_color=(0,0,0), background=(255,255,255), border_color=(0,0,0)):
        """Initiailize"""
        super().__init__("", font_size, font_color, "normal", line_width, top_left)#text, size, font_color, "bold", line_width, TL
        self.row_width = width
        self.__column_locations__ = [0]
        #self.relative_column_locations = self.__column_locations__
        self.__text_list__ = self.check_text_list(text_list)
        self.Show_rows = len(self.__text_list__)>0
        self.__count__ = 0
        self.set_count(self.__count__)
        self.__total_height__ = self.__update_rows_height__()
        self.row_border_color = self.check_color(border_color)
        self.row_background = self.check_color(background)
        #self.column_widths=[]
 
    def check_text_list(self, text_list=[]):
        """This method validates that every element in the text_list is a list of equal lenght"""
        try:
            if len(text_list)>0:
                check_len = len(text_list[0])
                print(check_len)
                same_size = not(sum([len(x)!=check_len for x in text_list]))
                print("Same size {}".format(same_size))
                assert(same_size==True)
        except:
            raise(RuntimeError("Every row must be a list containing the same number of elements"))
        return text_list
    
    @property
    def column_locations(self):
        return [location-self.Top_left[0] for location in self.__column_locations__]
    
    @column_locations.setter
    def column_locations(self, locations):
        locations = [local+self.Top_left[0] for local in locations]
        self.__set_column_locations__(locations)
        #self.__my_attr__ = value
    
    @property
    def bottom(self):
        return self.line_width+(self.__height__)*self.__count__
    
    def set_text_list(self, text_list):
        """This method first validates the text_list then sets the internal text_list and updates 
           the row count."""
        self.__text_list__ = self.check_text_list(text_list)
        self.set_count(self.__count__)
        self.__set_column_locations__(self.column_locations)
        self.Show_rows = True
    
    def set_count(self, count):
        """This method lets you add rows beyond the lenght of the text_list."""
        try:
            assert(count>=0 and int(count)==count)
        except:
            raise(RuntimeError("The row count must be a postive integer"))
        self.__count__ = max(count,len(self.__text_list__))
        self.__update_rows_height__()
        self.Show_rows = True
    
    def __update_rows_height__(self):
        #row_height = self.font_size+2+self.line_width*2
        self.__total_height__ = self.__count__*(self.__height__)
    
    def __set_column_locations__(self, locations=[0]):
        """This method sets the vertical dividers and text placement of the columns in the table."""
        try:
            assert(max(locations)<=self.row_width+self.Top_left[0])
            assert(min(locations)>=self.Top_left[0])
            if len(locations)<len(self.__text_list__[0]):
                more = len(self.__text_list__[0])-len(locations)
                step = 10
                start = locations[-1]+step
                stop = more*step+locations[-1]
                locations+=list(range(start, stop, step))
            #self.relative_column_locations = locations
            self.__column_locations__=locations#[local+self.Top_left[0] for local in locations]
        except:
            raise(RuntimeError("Column locations must all be greater than or equal to zero and be less than or equal to the row width."))
        
    def get_SVG_rows(self):
        if self.Show_rows:
            try:
                columns = len(self.__text_list__[0])
            except:
                columns = 1
            TL = list(self.Top_left)
            BR = [self.row_width,self.__height__]
            rect_obj = rectangle()
            rect_obj.top_left = TL
            rect_obj.bottom_right = BR
            rect_obj.background = self.row_background
            rect_obj.border_color = self.row_border_color
            rect_obj.line_width = self.line_width
            Text = ""
            for row in range(self.__count__):
                Text += draw_rec(rect_obj)
                try:
                    row_text = self.__text_list__[row]
                    Top_left = list(TL)
                    for self.text, x_local in zip(row_text, self.__column_locations__):
                        Top_left[0]=x_local
                        Text += SVG_text(Top_left, self.__font_size__, self.__height__, self.text, 
                                         self.font_color, self.font_weight)
                except:
                    pass
                TL[1]+=self.__height__
            bottom = TL[1]+self.line_width
            top = self.Top_left[1]+self.line_width
            for hor_local in self.__column_locations__:
                line = '<line x1="{0}" y1="{1}" x2="{0}" y2="{2}" '.format(hor_local, top, bottom)
                #line +=''
                line +='style="stroke:rgb{0};stroke-width:{1}"/>\n'.format(self.row_border_color, self.line_width)
                Text+=line
            return Text 
        else:
            return ""

# <codecell>

rows = Table_rows()
#rows.set_count(6)
text_list = [["Area\ntest"],["Area"],["Dog"],["Area"],["Area"]]
rows.set_text_list(text_list)
rows.column_locations=[0,40]
rows.__height__=30
print(rows.__count__)
print(rows.__total_height__)

print(rows.bottom)

print(rows.get_SVG_rows())
Text=Set_SVG_view(rows.row_width+2*rows.line_width, rows.bottom+rows.line_width, rows.get_SVG_rows())
#print(Text)
SVG(Text)
#SVG("<SVG>"+rows.get_SVG_rows()+"</SVG>")

# <codecell>

bottom = 81
line_width = 1
height = 16
count = 5
Test = line_width+(height)*count
print(Test)
bottom == Test

# <codecell>

first = 1
out = not(sum([len(x)!=first for x in [[0],[1],[2]]]))
print(out)

# <markdowncell>

# #Still working here

# <codecell>

class Table_rows(SVG_Text, Table_Header):
    def __init__(self, count=0, font_size=12, line_width=1, top_left=(0,0), text=[], width=100, font_color=(0,0,0), background=(255,255,255), border_color=(0,0,0)):
        super().__init__() #text, font_size, font_color, "bold", line_width, top_left
        
        self.row_height = self.font_size+2+self.line_width*2
        self.Rows_Top_left = list(top_left)
        self.width=width
        self.background=background
        self.border_color=border_color
        self.rows_exists=False
        self.set_row_text(text)
        
    def set_row_atrib(self, exists=False, count=1):
        """This method lets you set attributes of the rows of text"""
        self.rows_exists=exists
        try:
            assert(count>=0)
            assert(count == int(count))
            self.count = count #.count = count#
        except:
            raise(RuntimeError("Count must be a positive integer"))
        self.__update_rows_height__()
    
    def set_row_text(self, text=[]):
        """This method allow the user to add arrays of text to the table.  
           If the table has multiple columns then the list must be a list of lists."""
        if len(text)>0:
            self.Rows_text = text
            self.count=len(text)
            self.rows_exists = True
            self.__update_rows_height__()
        else:
            print("No text added")
            
    def __update_rows_height__(self):
        #row_height = self.font_size+2+self.line_width*2
        self.Total_height = self.count*(self.height)
    
    def get_SVG_rows(self):
        rect_dict = {'top_left':self.Rows_Top_left,'bottom_right':[self.width,self.height],
                     'back':self.background,'color':self.border_color,
                     'line width':self.line_width}
        if self.rows_exists:
            Row_text=""
            row_dict = rect_dict.copy()
            tl_row = list(self.Rows_Top_left)
            self.local_of_top_row = tl_row[1]
            row_dict["top_left"]=tl_row
            for i in range(self.count):
                Row_text+=draw_rec(row_dict)
                self.text_Top_left=tl_row
                try:
                    self.text = self.Rows_text[i]
                except:
                    self.text = ""
                Row_text+=self.get_SVG_text()
                tl_row[1]+=self.height
                
                
            return Row_text
        else:
            return ''
    

# <codecell>

rows = Table_rows(count=5)
rows.set_row_atrib(exists=True, count=5)

# <codecell>

print(rows.get_SVG_rows())

# <codecell>


# <codecell>

class SVG_table(Header, Table_rows):
    def __init__(self, rows=0, border=False, header="", Top_left=(0,0), width=200):#Bot_right=(200,30)):
        """Rows is the number of rows (not including the header). The border is a rectangle that
           is drawing around the table, the Top_left is the upper most left hand side of the table
           the Bot_right is the bottom right hand corner of the table relative to the top left."""
        #super(ChildB, self).__init__()
        super(Header, self).__init__(self, text=header, TL=Top_left, width=width)
        super(Table_rows, self).__init__(self, count=rows, top_left=Top_left width=width)
        self.table = {'line width':1, 'color':(0,0,0)}
        #self.rows = dict()#{'exists':False,'count':rows, 'text':[], 'font size':12, 'height':16}
        #self.set_row_atrib(count = rows)
        self.border = {'exists':border, 'line width':1, 'color':(0,0,0)}#black
        #self.header = Header(text=header, line_width=self.table['line width'])
        
        #self.set_header_atrib()
        #self.set_header_text(header)
        self.set_Top_left(Top_left)
        #self.set_Bot_right(Bot_right)
        self.set_background()
        self.row_text = []
        #self.Test.rows = 5
        
            
    #def set_Bot_right(self, Bot_right=(200,30)):
    #    """This method sets the bottom right hand corner of the table relative to the top left. """
    #    try:
    #        assert(min(Bot_right)>0)
    #        self.Bot_right = Bot_right
    #    except:
    #        raise(RuntimeError("You can't do that to tables.  The bottom right must be numbers greater than zero."))
            
    def set_Top_left(self, Top_left=(0,0)):
        """This method sets the top left hand corner of the table and thus moves the table around."""
        try:
            assert(min(Top_left)>=0)
            self.Top_left = Top_left
        except:
            raise(RuntimeError("You can't do that to tables.  The top left must be at locations greater than zero."))
        
    
    
    def set_border_attrib(self,line_width=1, color=(0,0,0)):
        """ This method let you set the border line width and color (default black)"""
        try:
            assert(min(color)>=0)
            assert(max(color)<256)
            self.border["color"]=color
        except:
            raise(RuntimeError("RGB color values must be between 0 and 255 inclusive"))
        try:
            assert(line_width>0)
            self.border['line width']=line_width
        except:
            raise(RuntimeError("Line width must be at least 1"))
    
    def set_border_exists(self, exists=False):
        """This method let you turn a border on after a table's creation"""
        self.border['exists']=exists
    
    def set_background(self, color=(255,255,255)):
        """This method sets the default color of the table background. Default color is white """
        try:
            assert(min(color)>=0)
            assert(max(color)<256)
            self.background=color
        except:
            raise(RuntimeError("RGB color values must be between 0 and 255 inclusive"))
    
    def __bottom_right_check__(self):
        BR = list(self.Bot_right)
        height=0
        if self.header.exists:
            height += self.header.height
        if self.rows['exists']:
            height += self.rows['height']
        #if self.border[exists
        if height > BR[1]:
            BR[1] = height
            self.Bot_right = tuple(BR)
    
        a="""def __draw_rec__(self, rect_dict):
        self.__bottom_right_check__()
        BR = rect_dict['bottom_right']
        TL = rect_dict['top_left']
        back = rect_dict['back']
        stroke_clr = rect_dict['color']
        lin_width = rect_dict['line width']
        svc_rec_list = ['<rect ',
                        'height="{}"'.format(BR[1]),
                        'width="{}" '.format(BR[0]-TL[0]),
                        'style="',
                        'fill:rgb{};'.format(back),
                        'stroke:rgb{};'.format(stroke_clr),
                        'stroke-width:{}" '.format(lin_width),
                        'x="{}" '.format(TL[0]+lin_width),
                        'y="{}" />\n'.format(TL[1]+lin_width)] #-TL[1]
        return ' '.join(svc_rec_list)"""
    
    def build_table(self):
        """This method returns a SVG text string of the SVG table"""
        #begin = '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">'
        SVG_text = ""
        TL = list(self.Top_left)
        rect_dict = {'top_left':TL,'bottom_right':self.Bot_right,
                     'back':self.background,'color':self.table['color'],
                     'line width':self.table['line width']}
        height = 0
        #print(rect_dict)
        if self.border['exists']:
            #<rect fill="white" height="40" stroke="black" stroke-width="2" width="250" x="2" y="2" />
            brd_dict = rect_dict.copy()
            brd_dict['color']=self.border['color']
            brd_dict['line width']=self.border['line width']
            Border_text = draw_rec(brd_dict)
            if self.border['line width']>self.table['line width']:
                offset = (self.border['line width']-self.table['line width'])
                TL[0]+= offset*2
                TL[1]+= offset*2
                off_x, off_y = 0, offset
            SVG_text +=Border_text#' '.join(Border_text)
            #print(rect_dict)
        #Set to default table line width and color
        if self.header.exists:#['exists']:
            """hdr_dict = rect_dict.copy()
            if self.Bot_right[1] < self.header.height:
                height = self.Bot_right[1]
            else:
                height = self.header.height
            #print(height)
            hdr_dict['bottom_right']=(self.Bot_right[0],height)
            hdr_dict['back']=self.header.background
            #print(hdr_dict)
            SVG_text += draw_rec(hdr_dict)
            x,y = hdr_dict['top_left']
            y+=int(floor((height+self.header.font_size)/2))#-off_y
            off_x = round(self.header.fonrt_size/2)
            Header_list = ['<text x="{}" '.format(x + off_x),
                           'y="{}" '.format(y),
                           'font-size= "{}" '.format(self.header.font_size),
                           'font-weight = "bold"',
                           'style="fill:rgb{}">'.format(self.header.font_color),
                           self.header.text,
                           '</text>\n'] #, 'fill={} ','font-style= "{}" ',"""
            
            SVG_text += self.header.get_SVG_header()#   " ".join(Header_list)
            #print(rect_dict)
        H_delta = (self.Bot_right[1] - TL[1] - height)
        if self.rows['exists'] and H_delta>0:
            h_delta = H_delta/self.rows
            #print(h_delta)
            row_dict = dict(rect_dict)
            
            tl_row = list(TL)
            tl_row[1]+=height
            self.__y_top_row = tl_row[1]
            #print(self.__y_top_row)
            row_dict["top_left"]=tl_row
            row_dict['bottom_right']=list(row_dict['bottom_right'])
            row_dict['bottom_right'][1]=h_delta
            #print(row_dict)
            for i in range(self.rows):
                SVG_text+=draw_rec(row_dict)
                tl_row[1]+=h_delta
                #print(row_dict)
            #print(self.__y_top_row)
        #SVG_text = SVG_text.strip(' \n ')
        SVG_text = '<svg viewBox="0 0 {0} {1}" version="1.1"  height="{1}">'.format(self.Bot_right[0]+off_x,self.Bot_right[1]+off_y*2+1)+SVG_text
        SVG_text += '</svg>'
        return SVG_text

# <codecell>

tab = SVG_table(border=True, header="Header\nnext",Bot_right=(300,120),rows=0)
tab.set_border_attrib(line_width=2)
#tab.header.

# <codecell>

txt = tab.build_table()
#txt= txt.replace('"0"','"10"')
print(txt)

# <codecell>

from IPython.display import SVG
SVG(txt)

# <codecell>


